В данном случае программа принимает на вход две строки в виде аргументов.
username и serial.
первая строка может принимать любой вид, при этом вторая строка является строго фиксированного типа.

Серийный номер должен состоять из трех чисел в 16 ричном формате соединенных между собой `-` и итоговая строка должно быть длиной в 26 символов.

Сам алгоритм проверки состоит из двух основных частей

1. Берется вводимая строка username и создается новая строка созданная благодаря небольшому так сказать перемешиванию исходных символов. Дальше эти две строки складываются (то есть просто приписываем к первой вторую) и над полученым результатом сложения используеться алгоритм хеширования MD5. Получаемый результат и являться исходным ключом.
2. Вторая часть попарно изменяет входящие три числа так что бы получился результат схожий с результатом хеширования.


```c++
void sub_12b0(int* two_ints, char* byte_array_1, char* byte_array_2) {
    int i = 0;

    int temp1, temp2;

    int result_1 = 0, result_2 = 0;

    int v1 = two_ints[0];
    int v2 = two_ints[1];

    do {
        temp1 = sub_1290(*(unsigned int *) (byte_array_1 + i) & v1);
        temp2 = sub_1290(*(unsigned int *) (byte_array_2 + i) & v2);
        i += 4;
        result_1 = result_1 * 2 ^ (temp1 ^ temp2) & 1;
    } while (i != 0x80);

    do {
        temp1 = sub_1290(*(unsigned int *) (byte_array_1 + i) & v1);
        temp2 = sub_1290(*(unsigned int *) (byte_array_2 + i) & v2);
        i += 4;
        result_2 = result_2 * 2 ^ (temp1 ^ temp2) & 1;
    } while (i != 0x100);

    two_ints[0] = result_1;
    two_ints[1] = result_2;
}
```

Для алгоритма попарного изменения даются заранее известные массивы байтов.
После чего для подсчета каждого итераций цикла мы сдвигаем по байтам и берем первых четыри байта для состовления числа.
Дальше попарно применяем бинарную операцию and и подсчитываем количество полученных единиц в бинарной репрезентаций чисел.
Следом над получившимися результатами применяем операцию xor и вытаскиваем последний бит.

полученный бит записывается для создания новой парой чисел


Правильный серийный номер тяжело из за того что бальшая часть информаций теряеться благотодя тому что происходит сохраняется последний бит после того как производиться операций xor над количеством единиц в каждом числе.
и в результате мы можем получить 0 и 1. но из за того что массивы чисел постоянно разные мы не можем определять какие именно изменения приводят к полученным результатам.

